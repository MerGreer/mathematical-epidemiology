<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>// Make *any* pre with class 'sagecell-sage' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({
  "inputLocation": "pre.sagecell-sage",
  "linked": true,
  "linkKey": "linked-sage",
  "autoeval": false,
  "languages": [
    "sage"
  ],
  "evalButtonText": "Evaluate (Sage)"
});
</script>
</head>
<body class="ignore-math">
<article class="activity project-like"><h4 class="heading">
<span class="type">Activity</span><span class="space"> </span><span class="codenumber">14.6</span><span class="period">.</span>
</h4>
<div class="para">The code block below produces the eigenvalues for the SEIR model. In other words, this code does the computation in Step 6 of the Next Generation Method as described in <a href="ch-the-next-generation-method.html#activity-learning-next-generation-seir" class="xref" data-knowl="./knowl/xref/activity-learning-next-generation-seir.html" data-reveal-label="Reveal" data-close-label="Close" title="Activity 14.4">Activity 14.4</a>. This code can also be used as a template for producing eigenvalues when the Next Generation Method produces a <span class="process-math">\(2\times 2\)</span> matrix.</div> <div class="para">Use the code to answer the questions below.</div> <pre id="activity-learning-next-generation-python-seir-1-3" class="ptx-sagecell sagecell-sage"><script type="text/x-sage">from sympy import * 
init_printing(use_unicode=True)

N = Symbol('N') 
gamma = Symbol('gamma')
beta = Symbol('beta')
kappa = Symbol('kappa')

# The F matrix of partial derivatives
F = Matrix([[0, beta * N], [0, 0]])
print("F = ", F)

# The V matrix of partial derivatives
V = Matrix([[kappa, 0], [-kappa, gamma]])
print("V = ", V)

# Computing V inverse and the Next Generation matrix
Vinv = V**-1
print("V inverse = ", Vinv)
FVinv = F * Vinv
print("Next Gen Matrix = ", FVinv)

# Calculating eigenvalues

R0eval = FVinv.eigenvals()
print("The eigenvalues and their multiplicities are: ", R0eval)
</script></pre> <ol class="decimal" id="activity-learning-next-generation-python-seir-1-4">
<li><div class="para">Four expressions are listed as <code class="code-inline tex2jax_ignore">Symbol</code> in lines 4 through 7 of the Python code. Compare these expressions with the entries in matrices <span class="process-math">\(F\)</span> and <span class="process-math">\(V\)</span> that we solved for in Step 5 of <a href="ch-the-next-generation-method.html#activity-learning-next-generation-seir" class="xref" data-knowl="./knowl/xref/activity-learning-next-generation-seir.html" data-reveal-label="Reveal" data-close-label="Close" title="Activity 14.4">Activity 14.4</a>. Show where each <code class="code-inline tex2jax_ignore">Symbol</code> occurs in matrices <span class="process-math">\(F\)</span> and <span class="process-math">\(V\text{,}\)</span> and state why these are all the terms we need to define as <code class="code-inline tex2jax_ignore">Symbol</code> so that Python will recognize them.</div></li>
<li><div class="para">Use lines 10 and 14 of the Python code to describe the syntax we use for entering matrices into Python.</div></li>
<li><div class="para">From line 18, state how we tell Python to compute the inverse of matrix <span class="process-math">\(V\text{,}\)</span> also written as <span class="process-math">\(V^{-1}\text{.}\)</span> From line 20, state how we tell Python to compute the matrix <span class="process-math">\(FV^{-1}\text{,}\)</span> which multiples matrix <span class="process-math">\(F\)</span> with matrix <span class="process-math">\(V^{-1}\text{.}\)</span> From line 25, state the command used to calculate the eigenvalues of matrix <span class="process-math">\(FV^{-1}\text{,}\)</span> and give the name we assign to that set of eigenvalues.</div></li>
<li><div class="para">The lines 11, 15, 19, 21, and 26 all include the <code class="code-inline tex2jax_ignore">print</code> command. Write out exactly what Python prints for each of these lines when we evaluate the code, and explain what each of these printed results means, in the context of the Next Generation Method.</div></li>
<li><div class="para">When we compute eigenvalues for a matrix, it is possible that an eigenvalue may occur more than once. The number of times an eigenvalue occurs is called the <em class="emphasis">multiplicity</em> of the eigenvalue. Python tells us the eigenvalues of a matrix, along with the multiplicity of each eigenvalue. Write out the eigenvalues of <span class="process-math">\(FV^{-1}\)</span> and the multiplicity of each eigenvalue. Explain how you know that each eigenvalue is a real number (and not a complex number, meaning that no part of the eigenvalue includes <span class="process-math">\(i=\sqrt{-1}\)</span>). Then state which eigenvalue is the largest, and confirm that this eigenvalue must represent a positive real number.</div></li>
</ol>
<div class="solutions"><details class="hint solution-like born-hidden-knowl"><summary class="knowl__link"><span class="type">Hint</span><span class="period">.</span></summary><div class="hint solution-like knowl__content"><ol class="decimal" id="activity-learning-next-generation-python-seir-2-1">
<li><div class="para">In Step 5 of <a href="ch-the-next-generation-method.html#activity-learning-next-generation-seir" class="xref" data-knowl="./knowl/xref/activity-learning-next-generation-seir.html" data-reveal-label="Reveal" data-close-label="Close" title="Activity 14.4">Activity 14.4</a>, we produced matrices for <span class="process-math">\(F\)</span> and <span class="process-math">\(V\text{.}\)</span> These matrices used letters, including Greek letters, to represent some parts of the model. We now designate each of those letters to be a <code class="code-inline tex2jax_ignore">Symbol</code> so that Python knows how to work with it. As an example, we write <code class="code-inline tex2jax_ignore">gamma = Symbol('gamma')</code> to give the name “gamma” to the Greek letter <span class="process-math">\(\gamma\text{.}\)</span> Python then knows to treat the entire text string <code class="code-inline tex2jax_ignore">gamma</code> as the single parameter value <span class="process-math">\(\gamma\)</span> whenever <span class="process-math">\(\gamma\)</span> appears in a mathematical expression, such as in matrix <span class="process-math">\(V\text{.}\)</span>
</div></li>
<li><div class="para">To enter a matrix, we type <code class="code-inline tex2jax_ignore">Matrix([])</code>. Inside the square brackets, we enter each row of the matrix, using its own set of square brackets, with commas separating the matrix entries. This system extends to matrices larger than <span class="process-math">\(2\times 2\text{.}\)</span>
</div></li>
<li><div class="para">These commands appear on the right-hand side of the equals <span class="process-math">\((=)\)</span> sign in each of the given lines. Notice that in each case we name the output. In particular, we give the name <code class="code-inline tex2jax_ignore">R0eval</code> to the output of the <code class="code-inline tex2jax_ignore">eigenvals</code> command so that we can print this output, using the command in line 26.</div></li>
<li>
<div class="para">The <code class="code-inline tex2jax_ignore">print</code> commands in this code block all include text, in quotation marks, followed by the name of a mathematical expression we have either entered into Python or asked Python to compute. As a result, Python prints this exact text first, telling us what we are seeing in the mathematical expression appearing just after the text.</div>
<div class="para">For instance, the code in line 19 tells Python to print the text “V inverse =” and then to print the actual matrix <span class="process-math">\(V^{-1}\)</span> that has been computed based on the matrix <span class="process-math">\(V\)</span> we entered.</div>
</li>
<li>
<div class="para">For matrix <span class="process-math">\(FV^{-1}\)</span> resulting from the Next Generation Method shown in <a href="ch-the-next-generation-method.html#activity-learning-next-generation-seir" class="xref" data-knowl="./knowl/xref/activity-learning-next-generation-seir.html" data-reveal-label="Reveal" data-close-label="Close" title="Activity 14.4">Activity 14.4</a>, the eigenvalues are <code class="code-inline tex2jax_ignore">0</code>, having multiplicity <span class="process-math">\(1\text{,}\)</span> and <code class="code-inline tex2jax_ignore">N*beta/gamma</code>, which equals <span class="process-math">\(\frac{\beta N}{\gamma}\text{,}\)</span> having multiplicity 1.</div>
<div class="para">It is not unusual for the eigenvalue equaling <span class="process-math">\(\mathcal{R}_0\)</span> to look different in Python than in mathematical writing. Rearranging and rewriting the Python version of <span class="process-math">\(\mathcal{R}_0\)</span> often makes the result easier to work with, both mathematically and for understanding its meaning.</div>
<div class="para">In the case of this activity’s output: the eigenvalue <code class="code-inline tex2jax_ignore">N*beta/gamma</code> is a positive real number, and is larger than <code class="code-inline tex2jax_ignore">0</code>, because all three values <span class="process-math">\(N\text{,}\)</span> <span class="process-math">\(\beta\text{,}\)</span> and <span class="process-math">\(\gamma\)</span> are positive real numbers in the SEIR model that led to this result.</div>
</li>
</ol></div></details></div></article><span class="incontext"><a class="internal" href="ch-the-next-generation-method.html#activity-learning-next-generation-python-seir">in-context</a></span>
</body>
</html>
