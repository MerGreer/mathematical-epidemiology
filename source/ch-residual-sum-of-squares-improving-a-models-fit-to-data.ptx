<chapter xml:id="ch-residual-sum-of-squares-improving-a-models-fit-to-data" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>* Residual Sum of Squares: Improving a Model's Fit to Data</title>

    <p>
      <term>***This chapter is under construction.***</term>
    </p>

    <introduction xml:id="intro-RSS">
      <objectives>
        <ul>
          <li>
            <p>
              Use data from case reports to implement a method for estimating the value of the transmission parameter <m>\beta</m>
            </p>
          </li>
          <li>
            <p>
              Understand how a <q>for</q> loop in Python helps us test many possible values of <m>\beta</m> with one click of the <c>Evaluate</c> button  
            </p>
          </li>
          <li>
            <p>
              Ensure that the results from our math-and-coding-based approach to estimating <m>\beta</m> make biological sense
            </p>
          </li>
        </ul>
      </objectives> 
  
      <p>
        So far, we have estimated <m>\beta</m> in two ways: (1) visually, making adjustments so that data and graphs are closer together, starting in <xref ref="ch-visualization-graphing-model-results-and-data"/>, and (2) using a formula involving <m>\mathcal{R}_0</m> and parameters from our model, such as in <xref ref="eq-R0-sir"/> and <xref ref="eq-R0-seir"/>, to substitute in values we could find from epidemiological information and solve for <m>\beta</m>, which is typically the only unknown value in the formula. In this chapter, we learn a new approach.     
      </p>  
  
      <p> 
        Begin in <xref ref="expl-RSS"/> by examining data points as well as values determined by an SI model. In this exploration, think about mathematical approaches to improve the model's fit to data.
      </p>
      
      <exploration xml:id="expl-RSS">
        <title>Visually Demonstrating Differences Between a Model and Data</title>
        <introduction>
          <p>
            This example focuses on an SI model, similar to what we worked with in <xref ref="ch-zombies-can-math-help"/> and <xref ref="ch-visualization-graphing-model-results-and-data"/>. Use the code shown, and its output, to answer the questions below.
          </p>
          <sage>
            <input>
              #Import packages
              import numpy as np
              import matplotlib.pyplot as plt
              from scipy.integrate import odeint

              #Include data from Zombie Game App
              t_steps = [0, 1, 2, 3, 4, 5, 6]
              I_data = [1, 2, 4, 10, 22, 40, 50]
              
              #Define the system of differential equations, and call it "hz"
              def hz(y, t):
                s, i = y #Define y as consisting of s and i, in that order
                dydt = [-beta * s * i, beta * s * i] #These formulas are the right-hand sides of the SI model
                return dydt
              
              beta = 0.03 #Give a value to beta
              y0 = [49, 1] #Set initial conditions for Susceptibles and Infectious, in that order
              t_range = np.arange(0.0, 7.0, 0.1) #Set the time range, then set the size of the time steps to use when "stepping through" to numerically solve
              
              sol = odeint(hz, y0, t_range) #Give the name "sol" to the lists of numerical values in the solution, and give "odeint" the information needed to solve

              print("I(0) = ", sol[0, 1])
              print("I(1) = ", sol[10, 1])
              print("I(2) = ", sol[20, 1])
              print("I(3) = ", sol[30, 1])
              print("I(4) = ", sol[40, 1])
              print("I(5) = ", sol[50, 1])
              print("I(6) = ", sol[60, 1])
              
              # Plotting commands are below
              plt.cla() #Clear (delete) any past plots
              plt.plot(t_steps, I_data,'o', markersize=4, color='orange', label='I(t) data')
              plt.plot(t_range, sol[:, 1], color='orange', linewidth=2, label='Modeled I(t)')
              plt.legend()
              plt.xlabel('Time')
              plt.ylabel('Infectious Population')
              plt.show()
            </input>
            <output>
            
            </output>
            </sage>
        </introduction>
  
        <task>
          <statement>
            <p>
              Copy the graph from the Python output: draw it by hand or print it out if you prefer a paper copy, or create a digital version you can edit, such as a screenshot. 
            </p>
            <ol>
              <li>
                <p>
                  For the values <m>I(0)</m>, <m>I(1)</m>, <m>I(2)</m>, <m>I(3)</m>, <m>I(4)</m>, <m>I(5)</m>, and <m>I(6)</m> that are printed out in the Python output above the graph, label on your copy of the graph where each value is shown.
                </p>
              </li>
              <li>
                <p>
                  Then write out in words what the values <m>I(0)</m>, <m>I(1)</m>, <m>I(2)</m>, <m>I(3)</m>, <m>I(4)</m>, <m>I(5)</m>, and <m>I(6)</m> represent: are these data points, or values generated by a mathematical model?
                </p>
              </li>
            </ol>
          </statement>
        </task>
  
        <task>
          <statement>
            <p>
              Next, read lines 7 and 8 in the Python code. 
            </p>
            <ol>
              <li>
                <p>
                  These values combine to form several points on the output graph. On your copy of the graph, label the points determined by lines 7 and 8.
                </p>
              </li>
              <li>
                <p>
                  Then write out in words what the values from lines 7 and 8 represent: are these data points, or values generated by a mathematical model?
                </p>
              </li>
            </ol>
          </statement>
        </task>
        
        <task>
          <statement>
            <p>
              We now put parts (a) and (b) together.
            </p>
            <ol>
              <li>
                <p>
                  Use your labeled graph to compare the values in part (a) with the values in part (b). Can you draw a visual way of comparing these values at each of the times <m>t=0</m>, <m>t=1</m>, <m>t=2</m>, <m>t=3</m>, <m>t=4</m>, <m>t=5</m>, and <m>t=6</m>?
                </p>
              </li>
              <li>
                <p>
                  Starting with the visual comparison you just described: What would change visually if the values from the model, and the values at each data point, were closer together?
                </p>
              </li>              
              <li>
                <p>
                  Turn your visual comparison ideas into some mathematical suggestions for identifying when the model and the data are closer together.
                </p>
              </li>
            </ol>
          </statement>
        </task>
        
      </exploration>
  
    </introduction>

    <!-- <section xml:id="sec-gaa">
      <title>Starter Example Comparing Data with a Model: Zombie Data</title>
      <p>Use Bates flu data. Discuss converting from New Cases to S, I, R and possibly other compartments. Also discuss different time scales (here or elsewhere): converting data and parameters between days, weeks, months, years.</p>
      <p>
        Suppose you have data to compare against your model. Which set of parameters is best? We start by revisiting the type of graph and data we saw with our (relatively simple) early-semester zombie models. Read through the following and make sure you understand what is happening in each command. 
      </p>

      <sage>
        <input>
          #Import packages
          import numpy as np
          import matplotlib.pyplot as plt
          from scipy.integrate import odeint
          
          plt.cla()  #Clear (delete) any past plots

          #Include data from Zombie Game App
          t_steps = [0, 1, 2, 3, 4, 5, 6]
          S_data = [49, 48, 46, 40, 28, 10, 0]
          
          #Define the system of differential equations, and call it "hz"
          def hz(y, t):
            s, i = y #Define y as consisting of s and i, in that order
            dydt = [-beta * s * i, beta * s * i] #These formulas are the right-hand sides of the SI model
            return dydt
                
          beta = 0.03 #Give a value to beta
          y0 = [49, 1] #Set initial conditions for Susceptibles and Infectious, in that order
          t_range = np.arange(0.0, 8.0, 0.1) #Set the time range, then set the size of the time steps to use when "stepping through" to numerically solve
          
          sol = odeint(hz, y0, t_range) #Give the name "sol" to the lists of numerical values in the solution, and give "odeint" the information needed to solve
          
          # Plotting commands are below
          plt.plot(t_steps, S_data,'o', markersize=4, color='blue')
          plt.plot(t_range, sol[:, 0], color='blue', linewidth=2, label='S(t)')
          plt.legend()
          plt.xlabel('time')
          plt.ylabel('population')
          plt.show()
        </input>
        <output>
        
        </output>
        </sage>

      </section> -->

      <section xml:id="sec-residual-sum-of-squares-introductory-example">
        <title>Residual Sum of Squares: An Introductory Example</title>

        <p>
          One way to compare data with the output of a model is by computing the Residual Sum of Squares, often abbreviated as RSS. When we work with a single model to try to improve the fit of the model to a data set, RSS is a commonly used option. <xref ref="activity-rss-intro"/> shows the steps for computing RSS for a model with one choice for a value of <m>\beta</m>. Then, <xref ref="sec-underlying-math-rss"/> provides more mathematical context for how RSS works. After that, <xref ref="sec-residual-sum-of-squares-quickly-comparing-multiple-parameter-values"/> shows how to compare RSS for different values of <m>\beta</m> used in the same model. 
          <!-- Last, <xref ref="sec-influenza-data-and-rss"/> demonstrates the use of RSS with a real-world data set, where we need to take extra care to ensure that our work is not just correct mathematically, but also makes sense biologically. -->
        </p>

        <activity xml:id="activity-rss-intro">
          <statement>
            <p>
              In <xref ref="expl-RSS"/> we worked with both a data set, and model output, for the Infectious population <m>I(t)</m> at times <m>t=0, 1, 2, 3, 4, 5, 6</m>. The data values and model output appear in <xref ref="table-si-model-data-values-and-model-output"/>, with model output rounded to two decimal places. 
            </p>
            <table xml:id="table-si-model-data-values-and-model-output">
              <title>SI Model: Data Values and Model Output for <m>I(t)</m></title>
              <tabular halign="center">
                <row header="yes">
                  <cell>Time </cell>
                  <cell>Data Value </cell>
                  <cell>Model Output</cell>
                </row>
                <row>
                  <cell>0</cell>
                  <cell>1</cell>
                  <cell>1.0</cell>
                </row>
                <row>
                  <cell>1</cell>
                  <cell>2</cell>
                  <cell>4.19</cell>
                </row>
                <row>
                  <cell>2</cell>
                  <cell>4</cell>
                  <cell>14.54</cell>
                </row>
                <row>
                  <cell>3</cell>
                  <cell>10</cell>
                  <cell>32.38</cell>
                </row>
                <row>
                  <cell>4</cell>
                  <cell>22</cell>
                  <cell>44.58</cell>
                </row>
                <row>
                  <cell>5</cell>
                  <cell>40</cell>
                  <cell>48.68</cell>
                </row>
                <row>
                  <cell>6</cell>
                  <cell>50</cell>
                  <cell>49.70</cell>
                </row>
              </tabular>
            </table>
            <p>
              RSS compares each Data Value from <xref ref="table-si-model-data-values-and-model-output"/> with the Model Output from the same time by subtracting one from the other and squaring the result. 
            </p>
            <ol>
              <li>
                <p>
                  Try at least two of these comparisons on your own: for times <m>t=1</m> and <m>t=2</m>, subtract the Model Output in <xref ref="table-si-model-data-values-and-model-output"/> from the corresponding Data Value and square the result. Later in this activity, we will compare these hand-computed values with the corresponding values computed via Python.
                </p>
              </li>
              <li>
                <p>
                  Read the code block below to identify where in the code, and how, we do each of the following. You may find it helpful to look up some of the Python commands online to better understand the details of how they work. Printing output is another way to build understanding: you can include commands such as <c>print(sol)</c> or <c>print(t_range)</c> near the bottom of the Python code block to be sure you understand the structures of <c>sol</c>, <c>t_range</c>, or other quantities.
                </p>
                <ol>
                  <li>
                    <p>
                      The default code computes the numbers of Susceptibles and the numbers of Infectious at times 0, 0.1, 0.2, 0.3, and so on, until time 6.9. Where and how does the code say to do this?
                    </p>
                  </li>
                  <li>
                    <p>
                      When we say to complete a command for <c>x in range(0,7)</c>, which values of <m>x</m> are we specifying? 
                    </p>
                  </li>
                  <li>
                    <p>
                      Line 24 begins with <c>for</c> and then, in lines 25, 26, and 27, gives three commands. The word <c>for</c> means to complete these commands repeatedly, as many times as specified in the <c>x in range(0,7)</c> command you focused on in part (b) above. What happens in each of the three commands following <c>for</c>? For line 27, connect your answer back to the command <c>RSS = 0</c> in line 22. 
                    </p>
                  </li>
                  <li>
                    <p>
                      Within line 25, how do we specify that we seek Model Output at times 0, 1, 2, and so on, but not the Model Output at non-integer times such as 0.3? Why do we need to specify that we seek Model Output only at integer-valued times? 
                    </p>
                  </li>
                </ol>
                <sage>
                  <input>
                    #Import packages
                    import numpy as np
                    import matplotlib.pyplot as plt
                    from scipy.integrate import odeint

                    #Include data from the Zombie Game App
                    t_steps = [0, 1, 2, 3, 4, 5, 6]
                    I_data = [1, 2, 4, 10, 22, 40, 50]

                    #Define the system of differential equations, and call it "hz"
                    def hz(y, t):
                      s, i = y #Define y as consisting of s and i, in that order
                      dydt = [-beta * s * i, beta * s * i] # These are the right-hand sides of the SI model
                      return dydt

                    beta = 0.03 #Give beta a value
                    y0 = [49, 1] #Set initial values for Susceptibles and Infectious, in that order
                    t_range = np.arange(0.0, 7.0, 0.1) #Set the time range, the set the size of the time steps to use when "stepping through" to numerically solve the system of differential equations

                    sol = odeint(hz, y0, t_range) #Give the name "sol" to the lists of numerical values in the solution, and give "odeint" the information needed to solve

                    RSS = 0 #Initialize the value of RSS to be 0

                    for x in range(0,7):
                      new_square = (I_data[x] - sol[10*x, 1])**2
                      print("Squared distance at time", x, "=", new_square)
                      RSS = RSS + new_square

                    print("RSS = ", RSS)
                  </input>
                  <output>
                    
                  </output>
                </sage>
              </li>
              <li>
                <p>
                  Run the code block. Compare its results with your results for <m>t=1</m> and <m>t=2</m> in part (1) of this Activity. Describe how the results are similar and how they are different, and provide an explanation for why they are not identical. 
                </p>
                <p>
                  Then examine all the results from the code, including the total value for RSS for this model with this data set. State at least two of your observations.
                </p>
              </li>
              <li>
                <p>
                  Once you understand how the code works, experiment with different values of <m>\beta</m>. Your goal is to improve the fit between the model and the data set. While adjusting <m>\beta</m>, consider including a plot of the graph showing both the solution curve of the model and the data points. You can do this by copying plotting commands from the Python block in this chapter's Exploration (lines 30 through 37) and pasting them into the bottom of the Python block in this activity.
                </p>
                <p>
                  Write about your experiments and their results. State how you improved the fit of the model to data by adjusting <m>\beta</m>, and include an explanation of how you know the fit is improved.
                </p>
              </li>
            </ol>
          </statement>
          <answer>
            <ol>
              <li>
                <p>
                  At time <m>t=1</m>, compute <m>(4.19-2)^2</m> to get the value <m>4.7961</m>. At time <m>t=2</m>, compute <m>(14.54-4)^2</m> to get the value <m>111.0916</m>. 
                </p>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      Line 20 tells Python to compute <c>sol</c>, which is the array of values of Susceptibles and Infectious at all times in <c>t_range</c>. Line 18 establishes <c>t_range</c> as the times from 0.0 to 6.9 using the command <c>t_range = np.arange(0.0, 7.0, 0.1)</c>. Here, <c>np.arange(0.0, 7.0, 0.1)</c> indicates that the range of time values in <c>t_range</c> should start at time 0.0 and end at time 7.0, moving in time increments of 0.1. This means we compute solutions at times 0.0, 0.1, 0.2, and so on, with the last solutions computed at time 6.9. To see the values in <c>t_range</c>, you can run the Python block with the added command <c>print(t_range)</c>. (We discussed these commands in <xref ref="exer-first-odeint-code"/> and are refreshing our memory on them here.)
                    </p>
                  </li>
                  <li>
                    <p>
                      The command <c>x in range(0,7)</c> specifies the values <m>x=0,1,2,3,4,5,6</m>. In general, Python begins with, and includes, the first number in a <c>range</c> command, and then stops at, but does not include, the last number in the <c>range</c> command. This is why <m>0</m> is included, but <m>7</m> is not. To see the values in <c>range(0,7)</c>, you can run the Python block with the added command <c>for x in range(0,7):</c> followed by the line <c>print(x)</c>. The second line needs to be indented.
                    </p>
                  </li>
                  <li>
                    <p>
                      The command in line 25 starts with the Data Value given in line 8 by <c>I_data[x]</c> and subtracts the Model Output given by <c>sol[10*x, 1]</c>. The resulting value is then squared, and the squared value is given the name <c>new_square</c>.
                    </p>
                    <p>
                      The command in line 26 prints the value <c>new_square</c> computed in line 25. Printing pieces of output can help us make sure the code is doing what we expect and want it to do.
                    </p>
                    <p>
                      The command in line 27 updates the value of <c>RSS</c> by adding in the most recently computed value of <c>new_square</c>. Earlier in the code, in line 22, we set the value of RSS to 0. This makes certain that we always being with <m>RSS=0</m> and add only the squared distances for our current comparison of Data Values with Model Outputs.
                    </p>
                  </li>
                  <li>
                    <p>
                      We select Model Output values only at integer-valued time steps by multiplying <c>x</c> by <c>10</c> when writing <c>sol[10*x, 1]</c>. Recall that the array <c>sol</c> contains Model Output for <m>S(t)</m> and <m>I(t)</m> for <m>t=0.0, 0.1, 0.2, 0.3, ..., 6.9</m>. We select Model Output at times <m>t=0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0</m> to correspond to the times at which Data Values exist for comparison. Since <c>x</c> takes on values from <m>0.0</m> to <m>6.9</m>, and since Python counts starting at <m>0</m>, then <c>sol[10*0, 1]</c> tells us the Model Output at time <m>0</m>, <c>sol[10*1, 1]</c> tells us the Model Output at time <m>1</m>, and so on, until <c>sol[10*6, 1]</c> tells us the Model Output at time <m>6</m>, where <m>6</m> is the last time for which we have a Data Value. 
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  The code produces the value <m>4.795784246749833</m> for the squared distance at time <m>t=1</m>. Our hand-computed value from part (1) of this Activity was <m>4.7961</m>. We see that these values are very close to each other. The difference between them is due to our rounding the values in <xref ref="table-si-model-data-values-and-model-output"/> to two decimal points. 
                </p>
                <p>
                  Similarly, the code produces the value <m>111.02234652523701</m> for the squared distance at time <m>t=2</m>, whereas our hand-computed value from part (1) of this Activity was <m>111.0916</m>. Again, the difference in values is due to rounding.
                </p>
                <p>
                  From here, make additional observations. This is open-ended. Observations may include noticing that the squared distances are notably larger when the data point is further from the value on the solution curve of the model, compared with when the data point is close to the value on the solution curve of the model. There may also be observations about the overall number computed for RSS. This overall RSS number is helpful when we reach part (4) and try to improve the fit of the model to data
                </p>
                <p>
                  Many other observations are possible.
                </p>
              </li>
              <li>
                <p>
                  This is open-ended. Values of <m>\beta</m> that are closer to <m>0.02</m> tend to produce a better fit of model to data, compared with the starting value of <m>\beta = 0.03</m>. You may wish to change additional decimal places of <m>\beta</m> to improve the fit even further.   
                </p>
                <p>
                  It is also appropriate to give visual (graph-based) and verbal (word-based) descriptions of changes in the graph of model and data, as the value of <m>\beta</m> changes.
                </p>
              </li>
            </ol>
          </answer> 
        </activity> 
      
    </section>


    <section xml:id="sec-underlying-math-rss">
        <title>The Underlying Math of RSS</title>

        <p>
          This section first provides a visual demonstration of what we do when computing RSS, and then presents RSS as a mathematical formula. A goal of this book is for you to dive into modeling, often using examples as a first way to understand how you can build and analyze your own models. We therefore started with <xref ref="activity-rss-intro"/>, which showed RSS in an example-based way. Now, while describing the mathematical approach more formally, we regularly refer back to <xref ref="activity-rss-intro"/>. 
        </p>
        <p>
          Start by considering <xref ref="fig-RSS-example-1"/>, which visualizes the subtraction that you did in Step 1 of <xref ref="activity-rss-intro"/> and that the Python code did in line 25. Each subtraction takes the form of a purple vertical line. The length of each vertical line is the distance between the Model Output and the Data Value at a specific time <m>t</m>.
        </p>
        <figure width="90%" xml:id="fig-RSS-example-1">
          <caption>Graph showing distances between Data Values and Model Output for the SI model from Exploration 10.1, using <m>\beta = 0.03</m></caption>
          <image source="fig-RSS-example-1.png" width="80%">
            <description>This graph shows Data Values as orange dots and Model Output as a smooth curve. The graph also shows the distances between Data Values and Model Output, at times <m>t=0, 1, 2, 3, 4, 5, 6,</m> for the SI model from Exploration 10.1, using <m>\beta = 0.03</m>.</description>
          </image> 
        </figure>
        <p>
          After computing vertical distances in <xref ref="activity-rss-intro"/>, we then square these distances. Take some time to think through the mathematical outcomes of squaring. One consequence of squaring each distance is that the results will always be non-negative, that is, either positive or zero. Throughout <xref ref="activity-rss-intro"/> we start with the Data Value and subtract the Model Output, but we could have subtracted in either order because the results after squaring are the same. When we later add together all the squared differences, each vertical distance contributes in a positive way to the sum (or keeps the sum the same, if the vertical distance is zero).
        </p>
        <p>
          Another aspect of squaring the distances is that a squaring function grows in an increasing way. This means that one large distance has the potential to contribute much more to the RSS value than several smaller distances. We can visualize this by thinking about the function  <m>y=x^2</m>. Just as the <m>y</m> values on the graph of <m>y=x^2</m> increase much more rapidly than their corresponding <m>x</m> values, the squares of the distances increase much more rapidly than the distances themselves. The result is that larger distances can contribute to a vastly increased RSS value.   
        </p>
        <p>
          Next, turn to <xref ref="fig-RSS-example-2"/> and notice that the Data Values are the same as in <xref ref="fig-RSS-example-1"/>, but the curve of Model Outputs grows more slowly. As a result, the vertical distances between Data Values and Model Outputs tend to be<mdash/>but are not always<mdash/>smaller. Previously, such as in <xref ref="ch-visualization-graphing-model-results-and-data"/>, we relied only on trial and error, along with personal judgment, to estimate parameter values that would bring the model simulation closer to our data points. Now, the RSS formula both helps us bring the model closer to the data and, importantly, provides a metric by which we can measure that closeness.
        </p>
     
        <figure width="90%" xml:id="fig-RSS-example-2">
          <caption>Graph showing distances between Data Values and Model Output for the SI model from Exploration 10.1, using <m>\beta = 0.023</m></caption>
          <image source="fig-RSS-example-2.png" width="80%">
            <description>This graph shows Data Values as orange dots and Model Output as a smooth curve. The graph also shows the distances between Data Values and Model Output, at times <m>t=0, 1, 2, 3, 4, 5, 6,</m> for the SI model from Exploration 10.1, using <m>\beta = 0.023</m>.</description>
          </image>
        </figure>

        <p>
          Here are the steps for computing RSS for a specific mathematical model, with specific parameter values, in comparison with a particular set of data values.
          
        </p>
        <ol>
          <li>
            <p>
              Start by determining the Model Output at each time when we have a corresponding Data Value. In <xref ref="activity-rss-intro"/>, the Data Values occur at times <m>t=0,1,2,3,4,5,6</m>, so we use Model Output values for each of those times. 
            </p>
            <p>
              Notice that the Data Values and Model Outputs count the same things: the number of current Infectious individuals. In some other models, we will need to take additional steps to ensure that the quantities in our model relate directly to the quantities in our data set.
            </p>
          </li>
          <li>
            <p>
              For each time <m>t</m>, subtract <m>(\mbox{Data Value at time }t - \mbox{Model Output Value at time }t)</m>.
            </p>
          </li>
          <li>
            <p>
              Compute the squares of each value you computed in the previous step. That is, for each time <m>t</m>, compute <m>(\mbox{Data Value at time }t - \mbox{Model Output Value at time }t)^2</m>.
            </p>
          </li>
          <li>
            <p>
              Add together all the squared values. The formula below relates to <xref ref="activity-rss-intro"/>, with Data Values at times <m>t=0,1,2,3,4,5,6</m>. In an example with different time values <m>t</m>, the summation may need to involve numbers other than the integers from <m>0</m> to <m>6</m>:
              <md number="yes">
                <mrow>\sum_{t=0}^{6} (\mbox{Data Value at time }t - \mbox{Model Output Value at time }t)^2 .</mrow>
              </md>
            </p>
          </li>
        </ol>
        <p>
          This formula allows us to compute RSS for each choice of <m>\beta</m> in our model. We then compare values of RSS for different choices of <m>\beta</m>, seeking the smallest RSS value among values of <m>\beta</m> that make sense biologically.
        </p>
        <p>
          That last sentence deserves extra emphasis: it is crucial that <m>\beta</m> make sense biologically! Many modelers are tempted to minimize the RSS value in any way they can, losing sight of the biological importance of parameter values. We emphasize, throughout this book, that our model parameters have biological meaning, and therefore the values we choose for those parameters need to make real-world sense. 
        </p>

        <!-- In <xref ref="sec-influenza-data-and-rss"/>, we discuss parameter values, RSS, and biological meaning in the context of influenza data. -->

      
    </section>

    <section xml:id="sec-residual-sum-of-squares-quickly-comparing-multiple-parameter-values">
      <title>Residual Sum of Squares: Quickly Comparing Multiple Parameter Values</title>

      <p>
        As we saw in <xref ref="sec-residual-sum-of-squares-introductory-example"/>, we can bring model simulations closer to a data set by trying different parameter values, such as by allowing <m>\beta</m> to take on different values. In the Python code block within <xref ref="activity-rss-intro"/>, for every value of <m>\beta</m> we wanted to try, we had to change the value of <m>\beta</m> within the code and run the code again. Here, we instead wrap another <c>for</c> loop around the RSS <c>for</c> loop, so that we can test multiple values of <m>\beta</m> with one click of the <c>Evaluate</c> button.
      </p>

      <activity xml:id="activity-rss-beta-loop">
        <statement>
          <p>
            This Activity focuses on coding, with the goal of comparing RSS values for multiple values of a parameter without having to run Python code separately for every value of that parameter. Start by reading the code in the Python block below, and use what you read to answer the questions that follow.  
          </p>
          <sage>
            <input>
              #Import packages 
              import numpy as np 
              import matplotlib.pyplot as plt  
              from scipy.integrate import odeint
              
              #Include data from the Zombie Game App 
              t_steps = [0, 1, 2, 3, 4, 5, 6]
              I_data = [1, 2, 4, 10, 22, 40, 50]
              
              #Define the system of differential equations, and call it "hz"
              def hz(y, t):
                s, i = y #Define y as consisting of s and i, in that order
                dydt = [-beta * s * i, beta * s * i] # These are the right-hand sides of the SI model
                return dydt
                
              y0 = [49, 1] #Set initial values for Susceptibles and Infectious, in that order
              t_range = np.arange(0.0, 7.0, 0.1) #Set the time range, the set the size of the time steps to use when "stepping through" to numerically solve the system of differential equations
              
              for beta_value in (0.01, 0.02, 0.03, 0.04, 0.05):
                beta = beta_value
                sol = odeint(hz, y0, t_range) #Give the name "sol" to the lists of numerical values in the solution, and give "odeint" the information needed to solve
                RSS = 0 #Initialize the value of RSS to be 0
                for x in range(0,7):
                  new_square = (I_data[x] - sol[10*x, 1])**2
                  #print("Squared distance at time", x, "=", new_square)
                  RSS = RSS + new_square
                print("When beta =", round(beta,4), ", RSS =", round(RSS,4))
            </input>
            <output>
              
            </output>
          </sage>
          <ol>
            <li>
              <p>
                Describe how we gave a value to <m>\beta</m> in the code within <xref ref="activity-rss-intro"/>, compared with how we give values to <m>\beta</m> now in the code for <xref ref="activity-rss-beta-loop"/>. State the lines of code in which <m>\beta</m> is given its values, and compare the commands used to give <m>\beta</m> its values, explaining how each command works.
              </p>
            </li>
            <li>
              <p>
                In <xref ref="activity-rss-intro"/> we run the command <c>sol = odeint(hz, y0, t_range)</c> and give RSS its initial value of <m>0</m> outside any <c>for</c> loop. Now, in <xref ref="activity-rss-beta-loop"/>, we run <c>odeint</c> and reset <c>RSS = 0</c> inside the new outer <c>for</c> loop, but before running the inner <c>for</c> loop to compute RSS for a specific value of <m>\beta</m>. Explain the reasoning for where in the code we run <c>odeint</c> and set <c>RSS=0</c>. 
              </p>
            </li>
            <li>
              <p>
                Discuss how indenting works for the nested <c>for</c> loops. Python requires correct indenting. 
              </p>
            </li>
            <li>
              <p>
                Discuss the commented-out <c>print</c> command in line 25. Why might we choose not to see these results in this code, whereas we wanted to see these results in <xref ref="activity-rss-intro"/>, where this command appeared on line 26? Then discuss the <c>print</c> command in line 27, and explain why the information it shows is especially helpful to us as we cycle through values of <m>\beta</m>.
              </p>
            </li>
          </ol>
        </statement>
        <answer>
          <ol>
            <li>
              <p>
                In <xref ref="activity-rss-intro"/> we give <m>\beta</m> just one value, in line 16, by writing <c>beta = 0.03</c>, that is, by naming <m>\beta</m> and using the <c>=</c> sign to assign a value to <m>\beta</m>. The default code gives <m>\beta</m> the value <m>0.03</m>, and we can change this value by changing <m>0.03</m> to a different number.
              </p>
              <p>
                In <xref ref="activity-rss-beta-loop"/> we state in line 19 that we will give <m>\beta</m> the values <m>0.01, 0.02, 0.03, 0.04,</m> and <m>0.05</m>, one at a time. The first time the <c>for</c> loop runs, <m>\beta</m> is given the first of this list of values, that is, <m>\beta = 0.01</m>. Each time the <c>for</c> loop runs, <m>\beta</m> is given the next value, as shown in line 20 of the code. In all, the default loop will run five times, once for each value of <m>\beta</m>, and <m>\beta</m> will take on each value one time. We can change the values in line 19 to run whichever values of <m>\beta</m> we like.
              </p>
            </li>
            <li>
              <p>
                For each value of <m>\beta</m>, we use Python to do two things: solve the system of differential equations for that value of <m>\beta</m>, and compute the resulting RSS value comparing our Data Values with the Model Output from the solved differential equations. The outer <c>for</c> loop cycles through different values of <m>\beta</m>. For each, we recompute the solution array <c>sol</c> by running <c>odeint</c> on line 21, and we reset <c>RSS = 0</c> on line 22. We are then ready to run the inner <c>for</c> loop, starting on line 23, where we compute the specific RSS value for the current value of <m>\beta</m>. It is important for computing this RSS value that we have reset <c>RSS = 0</c> so that we do not add new squared differences to a past (non-zero) RSS value.  
              </p>
            </li>
            <li>
              <p>
                Python syntax requires that we indent the commands within a <c>for</c> loop. Indenting also serves as a visual signal to us, indicating which <c>for</c> loop each command is part of. The commands within the outer <c>for</c> loop, including the first line of the inner <c>for</c> loop,  are indented the same amount. The commands within the inner <c>for</c> loop are indented further. Notice that the <c>print</c> command on line 27 is not as indented as commands on lines 24, 25, and 26. This tells us that line 27 is part of the outer <c>for</c> loop rather than the inner <c>for</c> loop.   
              </p>
            </li>
            <li>
              <p>
                The <c>print</c> command from line 25 was especially helpful in <xref ref="activity-rss-intro"/> when we were learning, and perhaps troubleshooting, the code for computing RSS for a specific value of <m>\beta</m>. In <xref ref="activity-rss-intro"/> this print command appeared in line 26, and it showed us the step-by-step squared distances computed in Python that would be added together to produce the total RSS value. We compared some of these squared distances with values we computed by hand, both to make sure Python was doing what we wanted, and to build student understanding of the meaning of the RSS value.  
              </p>
              <p>
                Once we understand how this <c>for</c> loop works when computing RSS, we do not usually need to print all the squared distances. This is the reason why the <c>print</c> command in line 25 of the code for <xref ref="activity-rss-beta-loop"/> is commented out. We can use this code if we want by removing the <c>#</c> at the start of the line, but now we are more focused on seeing the RSS results for each value of <m>\beta</m>. These RSS results appear due to the <c>print</c> command in line 27, and we compare them to determine which <m>\beta</m> values produce the smallest values for RSS.
              </p>
            </li>
          </ol>
        </answer> 
      </activity>

      
    </section>

    <!-- <section xml:id="sec-influenza-data-and-rss">
      <title>Influenza Data and RSS</title> -->

      <!-- <p>Use Bates flu data? Introduce RSS. Discuss improving model fit and show how to do it. Emphasize (!!!!!!!) biological suitability of parameter choices, noise in data, etc. Consider developing a range of very good parameters, rather than imagining there is some set of "best" parameters.</p> -->

      <!-- <p>
        Now try computing RSS using the 5-day influenza prevalence data computed in <xref ref="activity-h1n1-data-fall-2009"/>. The data are already written into the code block below. Time 0 is the same as October 6.
      </p>

      <p>
        Notice in the line <c>RSS = RSS + (I_prevalence_data[x] - sol[0 + 10 * x, 1])**2</c> that instead of writing <c>sol[0 + 10 * x, 0]</c> we write <c>sol[0 + 10 * x, 1]</c>. Changing the <c>0</c> to a <c>1</c> tells Python to use the next column of model values from the array of S, I, and R values, that is, to use column 1 of Infectious values rather than column 0 of Susceptible values. It is important to choose the correct column of model values when comparing with data values.
      </p> -->

      

      <!-- <sage>
        <input>
          #Import packages
          import numpy as np
          import matplotlib.pyplot as plt
          from scipy.integrate import odeint
          
          plt.cla()  #Clear (delete) any past plots
          
          #Include data from Zombie Game App
          t_steps = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
          I_prevalence_data = [5, 13, 15, 21, 27, 37, 57, 108, 146, 160, 157, 138, 102, 79, 66, 54, 45, 28, 7, 0]
          
          #Define the system of differential equations, and call it "hz"
          def hz(y, t):
            s, i, r = y #Define y as consisting of s and i, in that order
            dydt = [-beta * s * i, beta * s * i - gamma * i, gamma * i] #These formulas are the right-hand sides of the SI model
            return dydt
            
          beta = 0.00035 #Give a value to beta
          gamma = 0.33 # Give a value to gamma: 0.25-0.33 are good values for most versions of flu
          y0 = [1709, 5, 0] #Set initial conditions for S, I, and R. There were 1714 students on campus.
          t_range = np.arange(0.0, 40.0, 0.1) #Set the time range, then set the size of the time steps to use when "stepping through" to numerically solve
           
          sol = odeint(hz, y0, t_range) #Give the name "sol" to the lists of numerical values in the solution, and give "odeint" the information needed to solve
          
          # Plotting commands are below
          plt.plot(t_steps, I_prevalence_data,'o', markersize=4, color='orange')
          plt.plot(t_range, sol[:, 1], color='orange', linewidth=2, label='I(t)')
          plt.legend()
          plt.xlabel('time')
          plt.ylabel('population')
          plt.show()


          RSS = 0

          for x in range(0,20):
              RSS = RSS + (I_prevalence_data[x] - sol[0 + 10 * x, 1])**2
              #print(RSS) #Uncomment this command to see in-between RSS calculations

          print("RSS = ", RSS)
        </input>
        <output>
        
        </output>
        </sage> -->

    
  <!-- </section> -->

  <exercises xml:id="exercises-ch-rss">
    <exercise number="1">
      <p>
      The paper <em>Outbreak of 2009 Pandemic Influenza A (H1N1) at a New York City School</em> describes a high school outbreak from April 2009.<fn>The article appears in the New England Journal of Medicine in Volume 361, published in 2009, pages 2628-2636. The authors are Justin Lessler, Nicholas G. Reich, Derek A.T. Cummings, and the New York City Department of Health and Mental Hygiene Swine Influenza Investigation Team. Here is a link to the article: <url href="https://www.nejm.org/doi/full/10.1056/NEJMoa0906089">https://www.nejm.org/doi/full/10.1056/NEJMoa0906089.</url></fn> Data from the outbreak, along with 2-day prevalence data computed as in <xref ref="ch-preparing-influenza-data-to-compare-with-a-model"/>, appear in <xref ref="table-H1N1-NYC-HS"/>. We use only two days for prevalence because people with flu symptoms typically stay home. This model, therefore, supposes they may go to school briefly while feeling sick, but then they stay home and no longer spread the illness to others at the school. 
      </p>         
      <table xml:id="table-H1N1-NYC-HS">
        <title>H1N1 Influenza Data from a New York City High School, 2009</title>
        <tabular halign="center">
          <row header="yes">
            <cell>Date (Day) </cell>
            <cell>New Cases </cell>
            <cell>2-day Prevalence</cell>
          </row>
          <row>
            <cell>April 18 (Day 0)</cell>
            <cell>23</cell>
            <cell>23</cell>
          </row>
          <row>
            <cell>April 19 (Day 1)</cell>
            <cell>10</cell>
            <cell>33</cell>
          </row>
          <row>
            <cell>April 20 (Day 2)</cell>
            <cell>17</cell>
            <cell>50</cell>
          </row>
          <row>
            <cell>April 21 (Day 3)</cell>
            <cell>23</cell>
            <cell>73</cell>
          </row>
          <row>
            <cell>April 22 (Day 4)</cell>
            <cell>103</cell>
            <cell>176</cell>
          </row>
          <row>
            <cell>April 23 (Day 5)</cell>
            <cell>267</cell>
            <cell>420</cell>
          </row>
          <row>
            <cell>April 24 (Day 6)</cell>
            <cell>147</cell>
            <cell>557</cell>
          </row>
          <row>
            <cell>April 25 (Day 7)</cell>
            <cell>100</cell>
            <cell>640</cell>
          </row>
          <row>
            <cell>April 26 (Day 8)</cell>
            <cell>50</cell>
            <cell>667</cell>
          </row>
          <row>
            <cell>April 27 (Day 9)</cell>
            <cell>17</cell>
            <cell>581</cell>
          </row>
          <row>
            <cell>April 28 (Day 10)</cell>
            <cell>7</cell>
            <cell>321</cell>
          </row>
          <row>
            <cell>April 29 (Day 11)</cell>
            <cell>7</cell>
            <cell>181</cell>
          </row>
          <row>
            <cell>April 30 (Day 12)</cell>
            <cell>7</cell>
            <cell>88</cell>
          </row>
          <row>
            <cell>May 1 (Day 13)</cell>
            <cell>3</cell>
            <cell>41</cell>
          </row>
        </tabular>
      </table> 
      <ol>
        <li>
          <p>
            Use Python to plot the 2-day prevalence data.
          </p>
        </li>
        <li>
          <p>
            Use the following information to construct an SIR model with parameter values for this outbreak: we start with a population of 2934 people (2686 high school students and 248 employees); the infectious period was 2 days (to match the 2-day prevalence assumption); and <m>\mathcal{R}_0</m> for H1N1 has been estimated to be between 1.4 and 1.6.
          </p>
        </li>
        <li>
          <p>
            Use an RSS approach, along with the 2-day prevalence data and your SIR model, to select a preferred value of <m>\beta</m> for this SIR model. 
          </p>
          <p>
            In your homework, show your Python code, and show at least three different values of <m>\beta</m> that you tried, along with the corresponding RSS value for each value of <m>\beta</m>. Which value of <m>\beta</m> leads to the smallest RSS value? Confirm that this value of <m>\beta</m> makes biological sense, based on the numbers or ranges of numbers we know for <m>N</m>, <m>\mathcal{R}_0</m>, and <m>\gamma</m>.
          </p>
        </li>
        <li>
          <p>
            For the <m>\beta</m> value you selected in part (c), compare <m>\beta</m> with the values of <m>N</m>, <m>\mathcal{R}_0</m>, and <m>\gamma</m> for this model, using <xref ref="eq-R0-sir"/>. How close is the value of <m>\beta</m> you selected using RSS to the range of values of <m>\beta</m> that make sense in <xref ref="eq-R0-sir"/>? Discuss possible reasons for the outcome you found, whether you found that the <m>\beta</m> values are close or not very close.
          </p>
        </li>
      </ol>
    </exercise>

    <exercise number="2">
      <p>
      As described starting on page 356 of Mathematical Models in Population Biology and Epidemiology, second edition, by Fred Brauer and Carlos Castillo-Chavez, the village of Eyam, in England, was affected by bubonic plague in 1665-1666. There were two separate plague outbreaks, and <xref ref="table-rss-eyam"/> shows data for the second of these outbreaks. 
      </p>         
      <table xml:id="table-rss-eyam">
        <title>Plague Data from Eyam, 1666</title>
        <tabular halign="center">
          <row header="yes">
            <cell>Date (Day) </cell>
            <cell>Susceptibles </cell>
            <cell>Infectious</cell>
          </row>
          <row>
            <cell>July 3/4 (Day 0)</cell>
            <cell>235</cell>
            <cell>14.5</cell>
          </row>
          <row>
            <cell>July 19 (Day 15.5)</cell>
            <cell>201</cell>
            <cell>22</cell>
          </row>
          <row>
            <cell>August 3/4 (Day 31)</cell>
            <cell>153.5</cell>
            <cell>29</cell>
          </row>
          <row>
            <cell>August 19 (Day 46.5)</cell>
            <cell>121</cell>
            <cell>21</cell>
          </row>
          <row>
            <cell>September 3/4 (Day 62)</cell>
            <cell>108</cell>
            <cell>8</cell>
          </row>
          <row>
            <cell>September 19 (Day 77.5)</cell>
            <cell>97</cell>
            <cell>8</cell>
          </row>
          <row>
            <cell>October 4/5 (Day 93)</cell>
            <cell>Unknown</cell>
            <cell>Unknown</cell>
          </row>
          <row>
            <cell>October 20 (Day 108.5)</cell>
            <cell>83</cell>
            <cell>0</cell>
          </row>
        </tabular>
      </table> 
      <ol>
        <li>
          <p>
            Use Python to plot these data.
          </p>
        </li>
        <li>
          <p>
            Then, use the information that we start with a population of 250 people, the infectious period was 11 days, and <m>\mathcal{R}_0</m> has been estimated to be between 1.6 and 1.9, to construct an SIR model for this outbreak.
          </p>
        </li>
        <li>
          <p>
            Then use an RSS approach, along with the data and your SIR model, to select a preferred value of <m>\beta</m> for this SIR model. You may choose to compute <m>(\mbox{Data Value} - \mbox{Model Output})^2</m> separately for each day on which population values are available, or you can use a Python <c>for</c> loop for the six consecutive data points, and then add in <m>(\mbox{Data Value} - \mbox{Model Output})^2</m> for the October 20 data, in order to complete each total RSS value. Additionally, be sure that Python selects the correct value from its model output: this will require changing the <c>10</c> in the <c>sol[10*x, 1]</c> part of the code.
          </p>
          <p>
            (NOTE for the Bates Mathematical Models in Biology course in Fall 2024: you may compute RSS for comparing the model with just the first six data points, rather than needing to include the last data point, and rather than needing to figure out how to skip over the "Unknown" data point. However, if you can find a way to include the last data point, go ahead and include it!)
          </p>
          <p>
            In your homework, show your Python code, and show at least three different values of <m>\beta</m> that you tried, along with the corresponding RSS value for each value of <m>\beta</m>. Which value of <m>\beta</m> leads to the smallest RSS value? Confirm that this value of <m>\beta</m> makes biological sense, based on the numbers or ranges of numbers we know for <m>N</m>, <m>\mathcal{R}_0</m>, and <m>\gamma</m>.
          </p>
        </li>
      </ol>
    </exercise>

   </exercises>

  </chapter>